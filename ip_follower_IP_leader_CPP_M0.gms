*---------------------------------------------------------------------------
* Adapt: time discretization depending parameters
*---------------------------------------------------------------------------

$Offdigit

sets	Gamma	      	       time grid			/ 0*%gams.user1% /
	Gamma_start(Gamma)     first time point	                / 0 /
	Gamma_end(Gamma)       last time point	                / %gams.user1% / ;

alias (Gamma,i);

scalar time_periods_per_day ;
time_periods_per_day = %gams.user2% + 1
scalar Delta_t	Time step ;
Delta_t = 24/time_periods_per_day ;

*---------------------------------------------------------------------------
* Including data
*---------------------------------------------------------------------------
$include "gams_input_data/eex_spot_price.dat" ;
$include "gams_input_data/elec_load.dat" ;
$include "gams_input_data/heat_load.dat" ;

$include "gams_input_data/cpp_points.dat" ;

* $include "prosumer_revenue_conv.dat" ;
* $include "retailer_revenue_conv.dat" ;

* $include "P_im_conv.dat" ;


*---------------------------------------------------------------------------
* scalar parameters
*---------------------------------------------------------------------------
scalar	 gamma_eex_mean		Mean EEX price in EUR for MWh	                ;
gamma_eex_mean = sum(Gamma, gamma_eex(Gamma))/(%gams.user1% + 1)               ;

*---------------------------------------------------------------------------
* Quartal baseload price by EEX - german KWK Index
scalar   gamma_ret              Price of electrical energy for prosumer in EUR per MWh          /64.2/;
scalar   gamma_cpp_up_bd        Upper bound for the CPP markup in EUR per MWh                   /1000/;
scalar	 gamma_chp_fit		Feed-in tariff for electricity generated by CHP in EUR per MWh	/39.82/;
* Now gamma_chp_grid is included into gamma_chp_fit
*scalar	 gamma_chp_grid		Grid cost saved due to decentralized feed-in		         /0.005/;
scalar	 gamma_chp_sub		Subsidy for CHP electricity produced in EUR per MWh	        /54.1/;
scalar	 gamma_gas		Day price for natural gas in EUR per MWh			/73.9/;
scalar	 gamma_tax		Taxes etc prosumer pays for imported electricity in EUR per MWh /234.4/;
scalar	 unscaled_g_chp			gas consumed before the PEM fuel cell starts up in MWh	        /0.001/;
scalar	 eta_chp		Total power production efficiency of CHP		        /0.5/;
scalar	 unscaled_P_chp_e_max		Maximum electrical power generated by CHP in MWh	        /0.002/;
scalar	 k			Minimal fraction of P_chp_e_max CHP is able to produce	        /0.5/;
scalar	 zeta			Heat-to-electricity ratio of power production by CHP	        /2/;
scalar	 eta_bat_d		Discharge efficiency of the battery  			        /1/;
scalar	 eta_bat_c		Charge efficiency of the battery  			        /1/;
scalar	 eta_hsu_d		Discharge efficiency of the heat storage unit		        /1/;
scalar	 eta_hsu_c		Charge efficiency of the heat storage unit		        /1/;
scalar	 alpha_bat		Self-discharge rate of the battery    			        ;
scalar	 unscaled_E_start		Initial energy level in the battery    			        /0.0/;
scalar	 unscaled_E_end			Terminal energy level in the battery    		        /0.0/;
scalar	 unscaled_E_max			Maximum energy level (capacity) of the battery in MWh	        /0.013/;
scalar	 alpha_hsu		Self-discharge rate of the heat storage unit in MWh	        ;
scalar	 unscaled_H_start		Initial energy level in the heat storage unit in MWh	        /0.006/;
scalar	 unscaled_H_end     		Terminal energy level in the heat storage unit in MWh	        /0.006/;
scalar	 unscaled_H_min			Minimum energy level in the heat storage unit in MWh	        /0.006/;
scalar	 unscaled_H_max			Maximum energy level in the heat storage unit in MWh	        /0.012/;
scalar   unscaled_P_boiler_max	        Boiler power rating in MWh	                                /0.002/; 
scalar	 unscaled_P_bat_d_max		Maximum power allowed to discharge from battery in MWh	        /0.005/;
scalar	 unscaled_P_bat_c_max		Maximum power allowed to charge to battery in MWh	        /0.005/;
scalar	 P_lh_year		Yearly heat load of a house in MWh			        /10/;
scalar	 P_le_year		Yearly electrical load of a house in MWh		        /4/;
scalar   bigM                   bigM                                                            /1e4/;
scalar   bl_relax_tol           Relaxation tolerance for bilinear terms                         /0/;
scalar   g_chp		                                                                        ;
scalar   P_chp_e_max	                                                                        ;
scalar   E_start	                                                                        ;
scalar   E_end		                                                                        ;
scalar   E_max		                                                                        ;
scalar   H_start	                                                                        ;
scalar   H_end     	                                                                        ;
scalar   H_min		                                                                        ;
scalar   H_max		                                                                        ;
scalar   P_boiler_max	                                                                        ;
scalar   P_bat_d_max	                                                                        ;
scalar   P_bat_c_max

parameters P_lh_total(Gamma)	Total heat load of all houses ;
parameters P_le_total(Gamma)	Total electrical load of all houses;
parameters P_lh_intraday(Gamma) Unscaled heat demand ;
parameters P_im_up_bd(Gamma)    Upper bound for P_im ;

*---------------------------------------------------------------------------
* Computing scalar parameters; see above
*---------------------------------------------------------------------------
*gamma_ret       = unscaled_gamma_ret       / 10000 ;
*gamma_cpp_up_bd = unscaled_gamma_cpp_up_bd / 10000 ;
*gamma_chp_fit	= unscaled_gamma_chp_fit   / 10000 ;
*gamma_chp_sub	= unscaled_gamma_chp_sub   / 10000 ;
*gamma_gas	= unscaled_gamma_gas	   / 10000 ;
*gamma_tax	= unscaled_gamma_tax	   / 10000 ;
g_chp		= 10000 * unscaled_g_chp		 ;
P_chp_e_max	= 10000 * unscaled_P_chp_e_max	 ;
E_start	        = 10000 * unscaled_E_start	 ;
E_end		= 10000 * unscaled_E_end		 ;
E_max		= 10000 * unscaled_E_max		 ;
H_start	        = 10000 * unscaled_H_start	 ;
H_end     	= 10000 * unscaled_H_end     	 ;
H_min		= 10000 * unscaled_H_min		 ;
H_max		= 10000 * unscaled_H_max		 ;
P_boiler_max	= 10000 * unscaled_P_boiler_max	 ;
P_bat_d_max	= 10000 * unscaled_P_bat_d_max	 ;
P_bat_c_max	= 10000 * unscaled_P_bat_c_max	 ;
P_le_total(Gamma)    = P_le_total_orig_s(Gamma) * Delta_t * P_le_year;
*P_lh_intraday(Gamma) = P_lh_intraday_s(Gamma) * Delta_t ;
** P_lh_intraday(Gamma) is given in percent and not as a decimal fraction!
*P_lh_total(Gamma)    = (P_lh_year/100) * P_lh_intraday(Gamma) ;
P_lh_total(Gamma)    = P_lh_intraday_s(Gamma) * Delta_t ;

P_im_up_bd(Gamma) = P_le_total(Gamma) + (P_bat_c_max + P_boiler_max) * Delta_t ;
* g_chp		  = 1 * Delta_t ;
alpha_bat	  = 0 * Delta_t ;
alpha_hsu	  = 0 * Delta_t ;

*---------------------------------------------------------------------------
variables
*---------------------------------------------------------------------------
    obj_ir_upper        Upper level objective function value for CPP tariff
    obj_ir_lower	Lower level objective function value for CPP tariff ;

*---------------------------------------------------------------------------
* Primal integer variables of the upper level
*---------------------------------------------------------------------------

*positive variables
*
*    gamma_ret           Price of electrical energy for prosumer ;

integer variables

    gamma_cpp(Gamma)    CPP markup ;

*---------------------------------------------------------------------------
* Primal variables of the lower level
*---------------------------------------------------------------------------

*binary variables
*
*    z_on(Gamma)	        Control variable CHP off - on ;

positive variables

    P_im(Gamma)         Power imported from the grid
    P_chp_e(Gamma)      Electrical power generated by CHP
    P_chp_ex(Gamma)     Electrical power, generated by CHP, exported to grid
    P_chp_h(Gamma)      Heat power generated by CHP
    P_boiler(Gamma)     Power required to run the auxiliary boiler 
    P_hsu_c(Gamma)      Heat Power charged to the HSU
    H(Gamma)	        Energy level of heat storage unit
    E(Gamma)	        Energy level of battery
    P_bat_c(Gamma)      Power charged to the battery
    P_bat_d(Gamma)      Power discharged from the battery
    z_on(Gamma)	        Control variable CHP off - on
    z_up(Gamma)	        Control variable CHP is not activated in t - 1 is activated in t ;

*--------------------------------------------------------------------------- 
* Dual variables of the lower level problem
*--------------------------------------------------------------------------- 

positive variables
    
    l_z_on_up_bd(Gamma)
    l_z_up_up_bd(Gamma)
    l_H_up_bd(Gamma)
    l_H_low_bd(Gamma)
    l_E_up_bd(Gamma)
    l_boiler_up_bd(Gamma)
    l_bat_c_up_bd(Gamma)
    l_bat_d_up_bd(Gamma)
    
    l_z_up_lower(Gamma)
    l_chp_e_upper(Gamma)
    l_chp_e_lower(Gamma)
    l_chp_h_upper(Gamma)
    l_chp_ex_upper(Gamma)
    l_hsu_terminal_lower
    l_hsu_terminal_upper
    l_bat_terminal_lower
    l_bat_terminal_upper 
    l_elec_bal_l(Gamma)
    l_elec_bal_g(Gamma)
    l_hsu_input_l(Gamma)
    l_hsu_input_g(Gamma)
    l_bat_bal_l(Gamma)
    l_bat_bal_g(Gamma)
    l_hsu_bal_l(Gamma)
    l_hsu_bal_g(Gamma)
    l_init_hsu_l
    l_init_hsu_g
    l_init_bat_l 
    l_init_bat_g           ;

*---------------------------------------------------------------------------
* Auxiliary variables for nonlinear terms
*---------------------------------------------------------------------------

positive variables

    gamma_cpp_times_P_im(Gamma) ;

*---------------------------------------------------------------------------
* Bounds for primal variables of the lower level
*---------------------------------------------------------------------------

* Trivial upper bounds, not relevant for the lower level dualization

    P_im.up(Gamma)     = P_im_up_bd(Gamma) ;
    P_chp_ex.up(Gamma) = P_chp_e_max * Delta_t ;
    P_chp_e.up(Gamma)  = P_chp_e_max * Delta_t ;
    P_chp_h.up(Gamma)  = zeta * P_chp_e_max * Delta_t ;
    z_up.up(Gamma)     = 1 ;
    
* Not trivial upper bounds, relevant for the lower level dualization
    

    z_on.up(Gamma)     = 1 ;
    H.up(Gamma)        = H_max ;
    H.lo(Gamma)        = H_min ;
    E.up(Gamma)        = E_max ;
    P_boiler.up(Gamma) = P_boiler_max * Delta_t ;
    P_bat_c.up(Gamma)  = P_bat_c_max * Delta_t;
    P_bat_d.up(Gamma)  = P_bat_d_max * Delta_t;

*---------------------------------------------------------------------------
* Bounds for primal variables of the upper level and auxilary variables
*---------------------------------------------------------------------------
    gamma_cpp.lo(Gamma)            = 0 ;
    gamma_cpp.up(Gamma)            = gamma_cpp_up_bd ;
    gamma_cpp_times_P_im.up(Gamma) = gamma_cpp_up_bd * P_im_up_bd(Gamma) ;
    
*---------------------------------------------------------------------------
* Bounds for non-negative dual variables
*---------------------------------------------------------------------------

*    l_z_on_up_bd.up(Gamma)   = bigM ;
*    l_z_up_up_bd.up(Gamma)   = bigM ;
*    l_H_up_bd.up(Gamma)      = bigM ;
*    l_H_low_bd.up(Gamma)     = bigM ;
*    l_E_up_bd.up(Gamma)      = bigM ;
*    l_boiler_up_bd.up(Gamma) = bigM ;
*    l_bat_c_up_bd.up(Gamma)  = bigM ;
*    l_bat_d_up_bd.up(Gamma)  = bigM ;
    
*    l_z_up_lower.up(Gamma)   = bigM ;
*    l_chp_e_upper.up(Gamma)  = bigM ;
*    l_chp_e_lower.up(Gamma)  = bigM ;
*    l_chp_h_upper.up(Gamma)  = bigM ;
*    l_chp_ex_upper.up(Gamma) = bigM ;
    
*    l_hsu_terminal_lower.up  = bigM ;
*    l_hsu_terminal_upper.up  = bigM ;
*    l_bat_terminal_lower.up  = bigM ;                                          
*    l_bat_terminal_upper.up  = bigM ;
*    l_elec_bal_l.up(Gamma)   = bigM ;
*    l_elec_bal_g.up(Gamma)   = bigM ;
*    l_hsu_input_l.up(Gamma)  = bigM ;
*    l_hsu_input_g.up(Gamma)  = bigM ;
*    l_bat_bal_l.up(Gamma)      = bigM ;
*    l_hsu_bal_l.up(Gamma)      = bigM ;
*    l_init_hsu_l.up            = bigM ;
*    l_init_bat_l.up            = bigM ;    
*    l_bat_bal_g.up(Gamma)      = bigM ;
*    l_hsu_bal_g.up(Gamma)      = bigM ;
*    l_init_hsu_g.up            = bigM ;
*    l_init_bat_g.up            = bigM ;    

*---------------------------------------------------------------------------
* initial values
*---------------------------------------------------------------------------

    gamma_cpp.l(Gamma) = 70 ;
    
*---------------------------------------------------------------------------
equations
*---------------------------------------------------------------------------

    earnings_ir_upper             Upper level objective function for CPP tariff
    earnings_ir_lower 		  Lower level objective function for CPP tariff

    cpp_markup(Gamma)             CPP markup equation
    
    strong_duality                

    elec_bal(Gamma)	          electrical power balance
    hsu_input(Gamma)	          input to heat storage unit
    bat_bal(Gamma)                energy balance in the battery
    hsu_bal(Gamma)                energy balance in the heat storage unit
    z_up_lower(Gamma)             z_up lower bound
    chp_e_upper(Gamma)	          CHP electrical energy production upper bound
    chp_e_lower(Gamma)	          CHP electrical energy production lower bound
    chp_h_upper(Gamma)	          CHP heat energy production upper bound
    chp_ex_upper(Gamma)           P_chp_ex upper bound
    init_hsu(Gamma_start)         Fixation of initial energy level of heat storage unit
    init_bat(Gamma_start)         Fixation of initial energy level of battery
    hsu_terminal_lower(Gamma_end)
    hsu_terminal_upper(Gamma_end)
    bat_terminal_lower(Gamma_end)
    bat_terminal_upper(Gamma_end)                                             

*---------------------------------------------------------------------------
* Dual Feasibility          
*---------------------------------------------------------------------------      
    dual_P_im(Gamma)
    dual_P_chp_e(Gamma)
    dual_P_chp_ex(Gamma)
    dual_P_chp_h(Gamma)
    dual_P_boiler(Gamma)
    dual_P_hsu_c(Gamma)
    dual_H(Gamma)
    dual_E(Gamma)
    dual_P_bat_c(Gamma)
    dual_P_bat_d(Gamma)
    dual_z_on(Gamma)
    dual_z_up(Gamma)
    
*---------------------------------------------------------------------------
* Auxiliary constraints for nonlinear terms
*---------------------------------------------------------------------------
    mccormick_1(Gamma)
    mccormick_2(Gamma)
    mccormick_3(Gamma)
    bilinear_aux_cpp_1(Gamma)
    bilinear_aux_cpp_2(Gamma) ;

*---------------------------------------------------------------------------
* definition of equations
*---------------------------------------------------------------------------
*---------------------------------------------------------------------------
* Including Gomory cut data
*---------------------------------------------------------------------------
$include "gom_dual_variables_definition.dat";
$include "gom_equations_definition.dat";
$include "gom_cut_parameters.dat";
$include "gom_cutting_planes.dat";
*---------------------------------------------------------------------------
* Auxiliary constraints for nonlinear terms and McCormick
*---------------------------------------------------------------------------

mccormick_1(Gamma) .. gamma_cpp_times_P_im(Gamma) =G= gamma_cpp_up_bd * P_im(Gamma) + P_im_up_bd(Gamma) * gamma_cpp(Gamma) - gamma_cpp_up_bd * P_im_up_bd(Gamma) ;
mccormick_2(Gamma) .. gamma_cpp_times_P_im(Gamma) =L= gamma_cpp_up_bd * P_im(Gamma) ;
mccormick_3(Gamma) .. gamma_cpp_times_P_im(Gamma) =L= P_im_up_bd(Gamma) * gamma_cpp(Gamma) ;
bilinear_aux_cpp_1(Gamma) .. gamma_cpp_times_P_im(Gamma) =G= gamma_cpp(Gamma) * P_im(Gamma) - bl_relax_tol ;
bilinear_aux_cpp_2(Gamma) .. gamma_cpp_times_P_im(Gamma) =L= gamma_cpp(Gamma) * P_im(Gamma) + bl_relax_tol ;
    
*---------------------------------------------------------------------------
* definition of equations
*---------------------------------------------------------------------------

* objective function 

earnings_ir_upper .. obj_ir_upper =E= sum(Gamma, (gamma_ret * P_im(Gamma) + gamma_cpp_times_P_im(Gamma) - gamma_eex(Gamma) * P_im(Gamma))) ; 

earnings_ir_lower .. obj_ir_lower =E= sum(Gamma, + gamma_chp_fit * P_chp_ex(Gamma)
				    + gamma_chp_sub * P_chp_e(Gamma)
				    - gamma_gas * (1 + zeta) * P_chp_e(Gamma) / eta_chp
				    - gamma_gas * g_chp * z_up(Gamma)
				    - (gamma_tax + gamma_ret) * P_im(Gamma) - gamma_cpp_times_P_im(Gamma) 
				    )
;

cpp_markup(Gamma) .. gamma_cpp(Gamma)$((mod(ord(Gamma), time_periods_per_day) < cpp_time_start_1 + 1) or 
                    ((mod(ord(Gamma), time_periods_per_day) >= cpp_time_end_1 + 1) and (mod(ord(Gamma), time_periods_per_day) < cpp_time_start_2 + 1)) or
                    (mod(ord(Gamma), time_periods_per_day) >= cpp_time_end_2 + 1)
                    ) =E= 0 ;

elec_bal(Gamma)	..  P_im(Gamma) - P_le_total(Gamma) - P_boiler(Gamma) - P_bat_c(Gamma) + P_bat_d(Gamma) + P_chp_e(Gamma) - P_chp_ex(Gamma) =E= 0 ;

hsu_input(Gamma) .. P_hsu_c(Gamma) - P_chp_h(Gamma) - P_boiler(Gamma) =E= 0 ;

bat_bal(Gamma)$(ord(Gamma) > 1) .. E(Gamma) - (1-alpha_bat) * E(Gamma-1) + P_bat_d(Gamma-1) / eta_bat_d - eta_bat_c * P_bat_c(Gamma-1) =E= 0;

hsu_bal(Gamma)$(ord(Gamma) > 1) .. H(Gamma) - (1-alpha_hsu) * H(Gamma-1) + P_lh_total(Gamma-1) / eta_hsu_d - eta_hsu_c * P_hsu_c(Gamma-1) =E= 0;

z_up_lower(Gamma) .. z_on(Gamma) - z_on(Gamma - 1)$(ord(Gamma) > 1) - z_up(Gamma) =L= 0 ;

chp_e_upper(Gamma) .. P_chp_e(Gamma) - P_chp_e_max * Delta_t * z_on(Gamma) =L= 0;

chp_e_lower(Gamma) .. k * P_chp_e_max * Delta_t * z_on(Gamma) - P_chp_e(Gamma) =L= 0;

chp_h_upper(Gamma) .. P_chp_h(Gamma) - zeta * P_chp_e(Gamma) =L= 0;

* The ord function returns the ordinal position (beginning with 1) of an element of a set, the card function returns the size of a given set

chp_ex_upper(Gamma)   .. P_chp_ex(Gamma) - P_chp_e(Gamma) =L=0;

init_hsu(Gamma_start) .. H(Gamma_start) - H_start =E= 0;
init_bat(Gamma_start) .. E(Gamma_start) - E_start =E= 0;

hsu_terminal_lower(Gamma_end)  .. H_start - (1-alpha_hsu) * H(Gamma_end) + P_lh_total(Gamma_end) / eta_hsu_d - P_hsu_c(Gamma_end) * eta_hsu_c  =L=0;
hsu_terminal_upper(Gamma_end)  .. (1-alpha_hsu) * H(Gamma_end) - P_lh_total(Gamma_end) / eta_hsu_d + P_hsu_c(Gamma_end) * eta_hsu_c - H_max    =L=0;
bat_terminal_lower(Gamma_end)  .. E_start - (1-alpha_bat) * E(Gamma_end) + P_bat_d(Gamma_end) / eta_bat_d - P_bat_c(Gamma_end) * eta_bat_c     =L=0;
bat_terminal_upper(Gamma_end)  .. (1-alpha_bat) * E(Gamma_end) - P_bat_d(Gamma_end) / eta_bat_d + P_bat_c(Gamma_end) * eta_bat_c - E_max       =L=0;


* Dual Problem Feasibility + Strong Duality Conditions
*----------------------------------------------------------------------------

$include "gom_dual_feasibility.dat";
$include "gom_strong_duality.dat";

*---------------------------------------------------------------------------
* end of model definition
*---------------------------------------------------------------------------

model smart_grid /all/ ;
option minlp = BARON ;
option reslim = 3e2 ;
smart_grid.optcr = 1e-6;
solve smart_grid using minlp maximizing obj_ir_upper ;

*---------------------------------------------------------------------------
* display parameters, solution, ...
*---------------------------------------------------------------------------

* GAMS put facility for writing results to an external file
file results /ip_follower_IP_leader_CPP_M0.dat/ ;
put results ;
put '# Smart Grid Results'//;
results.nd = 20;
results.nw = 0; 
results.pw = 10000; 
put 'Objective Function Value of the Upper Level for CPP tariff' @75,  obj_ir_upper.l /;
put/;
put 'Objective Function Value of the Lower Level for CPP tariff' @75,  obj_ir_lower.l /;
put/;
*put 'Prosumer revenue for conventional tarif' @42,  prosumer_revenue_conv /;
*put/;
*put 'Retailer revenue for conventional tarif' @42,  retailer_revenue_conv /;
*put/;
put 'Number of time periods in one day' @40, time_periods_per_day /;
put/;
put 'CPP start time period 1' @40, cpp_time_start_1 /;
put/;
put 'CPP end time period 1' @40, cpp_time_end_1 /;
put/;
put 'CPP start time period 2' @40, cpp_time_start_2 /;
put/;
put 'CPP end time period 2' @40, cpp_time_end_2 /;
put/;
put 'gamma_eex_mean' @40,  gamma_eex_mean /;
put/;
put 'gamma_ret' @40, gamma_ret /;
put/;
put 'gamma_tax' @40, gamma_ret /;
put/;
loop((Gamma), put 'gamma_cpp' @20, Gamma.tl, @40, gamma_cpp.l(Gamma) /);
put/;
loop((Gamma), put 'P_im' @20, Gamma.tl, @40, P_im.l(Gamma) /);
put/;
loop((Gamma), put 'z_on' @20, Gamma.tl, @40, z_on.l(Gamma) /);
put/;
loop((Gamma), put 'z_up' @20, Gamma.tl, @40, z_up.l(Gamma) /);
put/;
loop((Gamma), put 'P_chp_e' @20, Gamma.tl, @40, P_chp_e.l(Gamma) /);
put/;
loop((Gamma), put 'P_chp_ex' @20, Gamma.tl, @40, P_chp_ex.l(Gamma) /);
put/;
loop((Gamma), put 'P_chp_h' @20, Gamma.tl, @40, P_chp_h.l(Gamma) /);
put/;
loop((Gamma), put 'P_boiler' @20, Gamma.tl, @40, P_boiler.l(Gamma) /);
put/;
loop((Gamma), put 'P_hsu_c' @20, Gamma.tl, @40, P_hsu_c.l(Gamma) /);
put/;
loop((Gamma), put 'H' @20, Gamma.tl, @40, H.l(Gamma) /);
put/;
loop((Gamma), put 'E' @20, Gamma.tl, @40, E.l(Gamma) /);
put/;
loop((Gamma), put 'P_bat_c' @20, Gamma.tl, @40, P_bat_c.l(Gamma) /);
put/;
loop((Gamma), put 'P_bat_d' @20, Gamma.tl, @40, P_bat_d.l(Gamma) /);
put/;
loop((Gamma), put 'P_le_total' @20, Gamma.tl, @40, P_le_total(Gamma) /);
put/;
loop((Gamma), put 'P_lh_total' @20, Gamma.tl, @40, P_lh_total(Gamma) /);

file gamma_cpp_bilevel /gamma_cpp_bilevel.dat/ ;
put gamma_cpp_bilevel ;
gamma_cpp_bilevel.nd=20;
gamma_cpp_bilevel.pw=10000;
put 'parameters gamma_cpp(Gamma) CPP markup in a bilevel optimal solution'/;
put '/'/;
loop((Gamma), put Gamma.tl, @20, gamma_cpp.l(Gamma) /);
put '/'/;

* GAMS put facility for writing results to an external csv file ready for python
file results_csv /ip_follower_IP_leader_CPP_M0.csv/ ;
put results_csv ;
results_csv.nd = 20;
results_csv.nw = 0;
results_csv.nr = 0;
results_csv.pw = 10000;
put 'Index;gamma_ret;gamma_eex;gamma_cpp;gamma_cpp_times_P_im;P_im;z_on;z_up;P_chp_e;P_chp_ex;P_chp_h;P_boiler;H;E;P_bat_c;P_bat_d;P_le_total;P_lh_total;P_hsu_c' ;
put/;
loop((Gamma), put Gamma.tl,
put';' gamma_ret,
put';' gamma_eex(Gamma),
put';' gamma_cpp.l(Gamma),
put';' gamma_cpp_times_P_im.l(Gamma),
put';' P_im.l(Gamma),
put';' z_on.l(Gamma),
put';' z_up.l(Gamma),
put';' P_chp_e.l(Gamma),
put';' P_chp_ex.l(Gamma),
put';' P_chp_h.l(Gamma),
put';' P_boiler.l(Gamma),
put';' H.l(Gamma),
put';' E.l(Gamma),
put';' P_bat_c.l(Gamma),
put';' P_bat_d.l(Gamma),
put';' P_le_total(Gamma),
put';' P_lh_total(Gamma),
put';' P_hsu_c.l(Gamma)
/);

file dual_bounds /values_of_dual_variables_for_bounds.dat/ ;
put dual_bounds ;
put '# Values of dual variables for lower level in order to determine good bounds'//;
dual_bounds.nd=20;
dual_bounds.pw=10000;
put 'parameters l_chp_e_upper_up(Gamma) '/;
put '/'/;
loop((Gamma), results.nd=20; put Gamma.tl, @20,  l_chp_e_upper.l(Gamma) /);
put '/ ;'/;
put 'parameters l_chp_e_lower_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,  	   l_chp_e_lower.l(Gamma) /);
put '/ ;'/;
put 'parameters l_z_up_lower_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,  	   l_z_up_lower.l(Gamma) /);
put '/ ;'/;
put 'parameters l_chp_h_upper_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,  	   l_chp_h_upper.l(Gamma) /);
put '/ ;'/;
put 'parameters l_chp_ex_upper_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,          l_chp_ex_upper.l(Gamma) /);
put '/ ;'/;

put 'parameters l_z_on_up_bd_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,           l_z_on_up_bd.l(Gamma) /);
put '/ ;'/;
put 'parameters l_H_up_bd_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,           l_H_up_bd.l(Gamma) /);
put '/ ;'/;
put 'parameters l_H_low_bd_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,           l_H_low_bd.l(Gamma) /);
put '/ ;'/;
put 'parameters l_E_up_bd_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,           l_E_up_bd.l(Gamma) /);
put '/ ;'/;
put 'parameters l_boiler_up_bd_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,           l_boiler_up_bd.l(Gamma) /);
put '/ ;'/;
put 'parameters l_bat_c_up_bd_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,           l_bat_c_up_bd.l(Gamma) /);
put '/ ;'/;
put 'parameters l_bat_d_up_bd_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,           l_bat_d_up_bd.l(Gamma) /);
put '/ ;'/;

put 'parameter l_hsu_terminal_lower_up' 
put /;
put '/' l_hsu_terminal_lower.l '/ ;'
put /;
put 'parameter l_hsu_terminal_upper_up'
put /;
put '/' l_hsu_terminal_upper.l '/ ;'
put /;
put 'parameter l_bat_terminal_lower_up' 
put /;
put '/' l_bat_terminal_lower.l '/ ;'
put /;
put 'parameter l_bat_terminal_upper_up' 
put /;
put '/' l_bat_terminal_upper.l '/ ;'
put /;

put 'parameters l_elec_bal__lup(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,  	  l_elec_bal_l.l(Gamma) /);
put '/ ;'/;
put 'parameters l_elec_bal_g_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,  	  l_elec_bal_g.l(Gamma) /);
put '/ ;'/;
put 'parameters l_hsu_input_l_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,  	  l_hsu_input_l.l(Gamma) /);
put '/ ;'/;
put 'parameters l_hsu_input_g_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,  	  l_hsu_input_g.l(Gamma) /);
put '/ ;'/;
put 'parameters l_bat_bal_l_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,          l_bat_bal_l.l(Gamma) /);
put '/ ;'/;
put 'parameters l_bat_bal_g_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,          l_bat_bal_g.l(Gamma) /);
put '/ ;'/;
put 'parameters l_hsu_bal_l_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,          l_hsu_bal_l.l(Gamma) /);
put '/ ;'/;
put 'parameters l_hsu_bal_g_up(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,          l_hsu_bal_g.l(Gamma) /);
put '/ ;'/;
put 'parameter l_init_hsu_l_up' 
put /;
put '/' l_init_hsu_l.l '/ ;'
put /;
put 'parameter l_init_hsu_g_up' 
put /;
put '/' l_init_hsu_g.l '/ ;'
put /;
put 'parameter l_init_bat_up'
put /;
put '/' l_init_bat_l.l '/ ;'
put 'parameter l_init_bat_up'
put /;
put '/' l_init_bat_g.l '/ ;'
put /;

put 'parameters l_elec_bal_l_lo(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,  	  l_elec_bal_l.l(Gamma) /);
put '/ ;'/;
put 'parameters l_elec_bal_g_lo(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,  	  l_elec_bal_g.l(Gamma) /);
put '/ ;'/;
put 'parameters l_hsu_input_l_lo(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,  	  l_hsu_input_l.l(Gamma) /);
put '/ ;'/;
put 'parameters l_hsu_input_g_lo(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,  	  l_hsu_input_g.l(Gamma) /);
put '/ ;'/;
put 'parameters l_bat_bal_l_lo(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,          l_bat_bal_l.l(Gamma) /);
put '/ ;'/;
put 'parameters l_bat_bal_g_lo(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,          l_bat_bal_g.l(Gamma) /);
put '/ ;'/;
put 'parameters l_hsu_bal_l_lo(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,          l_hsu_bal_l.l(Gamma) /);
put '/ ;'/;
put 'parameters l_hsu_bal_g_lo(Gamma) '/;
put '/'/;
loop((Gamma), put Gamma.tl, @20,          l_hsu_bal_g.l(Gamma) /);
put '/ ;'/;
put 'parameter l_init_hsu_l_lo'
put /;
put '/' l_init_hsu_l.l '/ ;'
put '/ ;'/;
put 'parameter l_init_hsu_g_lo'
put /;
put '/' l_init_hsu_g.l '/ ;'
put /;
put 'parameter l_init_bat_l_lo'
put /;
put '/' l_init_bat_l.l '/ ;'
put /;
put 'parameter l_init_bat_g_lo'
put /;
put '/' l_init_bat_g.l '/ ;'
put /;

*--------------------------------
* 
*--------------------------------


parameters gomory_P_im(Gamma);
parameters gomory_P_chp_h(Gamma);
parameters gomory_P_chp_e(Gamma);
parameters gomory_z_on(Gamma);
parameters gomory_z_up(Gamma);
parameters gomory_P_bat_c(Gamma);
parameters gomory_P_bat_d(Gamma);
parameters gomory_E(Gamma);
parameters gomory_P_boiler(Gamma);
parameters gomory_H(Gamma);
parameters gomory_P_chp_ex(Gamma);
parameters gomory_P_hsu_c(Gamma);
parameter gomory_right_side;

* calculate gomory parameters for P_im
loop((Gamma), gomory_P_im(Gamma)= l_elec_bal_l.l(Gamma) - l_elec_bal_g.l(Gamma));

* calculate gomory parameters for P_chp_h
loop((Gamma), gomory_P_chp_h(Gamma) = l_chp_h_upper.l(Gamma) - (l_hsu_input_l.l(Gamma) - l_hsu_input_g.l(Gamma)));

* calculate gomory parameters for P_chp_e
loop((Gamma), gomory_P_chp_e(Gamma)= (l_elec_bal_l.l(Gamma) - l_elec_bal_g.l(Gamma)) + l_chp_e_upper.l(Gamma) - l_chp_e_lower.l(Gamma) - zeta * l_chp_h_upper.l(Gamma) - l_chp_ex_upper.l(Gamma));

* calculate gomory parameters for z_on
loop((Gamma), gomory_z_on(Gamma) = l_z_on_up_bd.l(Gamma) + l_z_up_lower.l(Gamma) - l_z_up_lower.l(Gamma-1)$(ord(Gamma) > 1) - P_chp_e_max * Delta_t * l_chp_e_upper.l(Gamma) + k * P_chp_e_max * Delta_t * l_chp_e_lower.l(Gamma));

* calculate gomory parameters for z_up
loop((Gamma), gomory_z_up(Gamma) = l_z_up_up_bd.l(Gamma) - l_z_up_lower.l(Gamma));

* calculate gomory parameters for P_bat_c
loop(Gamma$(ord(Gamma)<card(Gamma)), gomory_P_bat_c(Gamma) = l_bat_c_up_bd.l(Gamma) - (l_elec_bal_l.l(Gamma) - l_elec_bal_g.l(Gamma)) - (l_bat_bal_l.l(Gamma-1)$(ord(Gamma) > 1) - l_bat_bal_g.l(Gamma-1)$(ord(Gamma) > 1)) * eta_bat_c);
loop(Gamma$(ord(Gamma)=card(Gamma)), gomory_P_bat_c(Gamma) = l_bat_c_up_bd.l(Gamma) - (l_elec_bal_l.l(Gamma) - l_elec_bal_g.l(Gamma)) - (l_bat_bal_l.l(Gamma-1) - l_bat_bal_g.l(Gamma-1)) * eta_bat_c - eta_bat_c * l_bat_terminal_lower.l + eta_bat_c * l_bat_terminal_upper.l);

* calculate gomory parameters for P_bat_d
loop(Gamma$(ord(Gamma)<card(Gamma)), gomory_P_bat_d(Gamma) = l_bat_d_up_bd.l(Gamma) + (l_elec_bal_l.l(Gamma) - l_elec_bal_g.l(Gamma)) + (l_bat_bal_l.l(Gamma-1)$(ord(Gamma) > 1) - l_bat_bal_g.l(Gamma-1)$(ord(Gamma) > 1))/eta_bat_d);
loop(Gamma$(ord(Gamma)=card(Gamma)), gomory_P_bat_d(Gamma) = l_bat_d_up_bd.l(Gamma) + (l_elec_bal_l.l(Gamma) - l_elec_bal_g.l(Gamma)) + (l_bat_bal_l.l(Gamma-1) - l_bat_bal_g.l(Gamma-1))/eta_bat_d + l_bat_terminal_lower.l/eta_bat_d - l_bat_terminal_upper.l/eta_bat_d;)

* calculate gomory parameters for E
loop(Gamma$(ord(Gamma)<card(Gamma)), gomory_E(Gamma) = l_E_up_bd.l(Gamma) + (l_bat_bal_l.l(Gamma)$(ord(Gamma) > 1) - l_bat_bal_g.l(Gamma)$(ord(Gamma) > 1)) - (1-alpha_bat) * (l_bat_bal_l.l(Gamma-1)$(ord(Gamma) > 1) - l_bat_bal_g.l(Gamma-1)$(ord(Gamma) > 1)) + (l_init_bat_l.l$(ord(Gamma) = 1) - l_init_bat_g.l$(ord(Gamma) = 1)));
loop(Gamma$(ord(Gamma)=card(Gamma)), gomory_E(Gamma) = l_E_up_bd.l(Gamma) + (l_bat_bal_l.l(Gamma) - l_bat_bal_g.l(Gamma)) - (1-alpha_bat) * (l_bat_bal_l.l(Gamma-1) - l_bat_bal_g.l(Gamma-1)) - (1 - alpha_bat) * l_bat_terminal_lower.l + (1 - alpha_bat) * l_bat_terminal_upper.l);

* calculate gomory parameters for P_boiler
loop((Gamma), gomory_P_boiler(Gamma)= l_boiler_up_bd.l(Gamma) - (l_elec_bal_l.l(Gamma) - l_elec_bal_g.l(Gamma)) - (l_hsu_input_l.l(Gamma) - l_hsu_input_g.l(Gamma)));

* calculate gomory parameters for H
loop(Gamma$(ord(Gamma)<card(Gamma)), gomory_H(Gamma) = l_H_up_bd.l(Gamma) - l_H_low_bd.l(Gamma) + (l_hsu_bal_l.l(Gamma)$(ord(Gamma) > 1) - l_hsu_bal_g.l(Gamma)$(ord(Gamma) > 1)) - (1 - alpha_hsu) * (l_hsu_bal_l.l(Gamma-1)$(ord(Gamma) > 1) - l_hsu_bal_g.l(Gamma-1)$(ord(Gamma) > 1)) + (l_init_hsu_l.l$(ord(Gamma) = 1) - l_init_hsu_g.l$(ord(Gamma) = 1)));
loop(Gamma$(ord(Gamma)=card(Gamma)), gomory_H(Gamma) = l_H_up_bd.l(Gamma) - l_H_low_bd.l(Gamma) + (l_hsu_bal_l.l(Gamma) - l_hsu_bal_g.l(Gamma)) - (1-alpha_hsu) * (l_hsu_bal_l.l(Gamma-1) - l_hsu_bal_g.l(Gamma-1))  - (1 - alpha_hsu) * l_hsu_terminal_lower.l + (1 - alpha_hsu) * l_hsu_terminal_upper.l);

* calculate gomory parameters for P_chp_ex
loop((Gamma), gomory_P_chp_ex(Gamma) = - (l_elec_bal_l.l(Gamma) - l_elec_bal_g.l(Gamma)) + l_chp_ex_upper.l(Gamma));

* calculate gomory parameters for P_hsu_c
loop(Gamma$(ord(Gamma)<card(Gamma)), gomory_P_hsu_c(Gamma) = (l_hsu_input_l.l(Gamma) - l_hsu_input_g.l(Gamma)) - eta_hsu_c * (l_hsu_bal_l.l(Gamma-1)$(ord(Gamma) > 1) - l_hsu_bal_g.l(Gamma-1)$(ord(Gamma) > 1)));
loop(Gamma$(ord(Gamma)=card(Gamma)), gomory_P_hsu_c(Gamma) = (l_hsu_input_l.l(Gamma) - l_hsu_input_g.l(Gamma)) - eta_hsu_c * (l_hsu_bal_l.l(Gamma-1) - l_hsu_bal_g.l(Gamma-1)) - eta_hsu_c * l_hsu_terminal_lower.l + eta_hsu_c * l_hsu_terminal_upper.l;);

* calculate gomory parameters for right side
gomory_right_side = sum((Gamma), l_z_up_up_bd.l(Gamma) + l_z_on_up_bd.l(Gamma) + H_max * l_H_up_bd.l(Gamma) - H_min * l_H_low_bd.l(Gamma) + E_max * l_E_up_bd.l(Gamma) + P_boiler_max * Delta_t * l_boiler_up_bd.l(Gamma) + P_bat_c_max * Delta_t * l_bat_c_up_bd.l(Gamma) + P_bat_d_max * Delta_t * l_bat_d_up_bd.l(Gamma) + P_le_total(Gamma) * (l_elec_bal_l.l(Gamma) - l_elec_bal_g.l(Gamma)) - P_lh_total(Gamma-1)$(ord(Gamma) > 1) / eta_hsu_d * (l_hsu_bal_l.l(Gamma-1)$(ord(Gamma) > 1) - l_hsu_bal_g.l(Gamma-1)$(ord(Gamma) > 1)) + H_start * (l_init_hsu_l.l$(ord(Gamma) = 1) - l_init_hsu_g.l$(ord(Gamma) = 1)) + E_start * (l_init_bat_l.l)$(ord(Gamma) = 1) - l_init_bat_g.l$(ord(Gamma) = 1)) 
+ sum(Gamma_end,(- H_start - P_lh_total(Gamma_end) / eta_hsu_d) * l_hsu_terminal_lower.l + (H_max + P_lh_total(Gamma_end) / eta_hsu_d ) * l_hsu_terminal_upper.l - E_start * l_bat_terminal_lower.l + E_max * l_bat_terminal_upper.l);

file parcheck /parametercheck.csv/
put parcheck;
parcheck.nd=20;
parcheck.pw=1000;
$include calculate_parameters.dat

file gompar /gomory_parameters.csv/;
put gompar;
gompar.nd=20;
gompar.pw=1000;

put "Variable;gomory_cut_value"/;
loop(Gamma,put P_im(Gamma),";",gomory_P_im(Gamma)/;);
loop(Gamma,put P_chp_h(Gamma),";",gomory_P_chp_h(Gamma)/;);
loop(Gamma,put P_chp_e(Gamma),";",gomory_P_chp_e(Gamma)/;);
loop(Gamma,put z_on(Gamma),";",gomory_z_on(Gamma)/;);
loop(Gamma,put z_up(Gamma),";",gomory_z_up(Gamma)/;);
loop(Gamma,put P_bat_c(Gamma),";",gomory_P_bat_c(Gamma)/;);
loop(Gamma,put P_bat_d(Gamma),";",gomory_P_bat_d(Gamma)/;);
loop(Gamma,put E(Gamma),";",gomory_E(Gamma)/;);
loop(Gamma,put P_boiler(Gamma),";",gomory_P_boiler(Gamma)/;);
loop(Gamma,put H(Gamma),";",gomory_H(Gamma)/;);
loop(Gamma,put P_chp_ex(Gamma),";",gomory_P_chp_ex(Gamma)/;);
loop(Gamma,put P_hsu_c(Gamma),";",gomory_P_hsu_c(Gamma)/;);
put "right_side",";",gomory_right_side;
